<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Gavin on Backend Technology]]></title>
  <link href="http://gavinhuang.github.io/atom.xml" rel="self"/>
  <link href="http://gavinhuang.github.io/"/>
  <updated>2014-10-08T18:18:31+08:00</updated>
  <id>http://gavinhuang.github.io/</id>
  <author>
    <name><![CDATA[Gavin Huang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何让nosql数据库支持事务]]></title>
    <link href="http://gavinhuang.github.io/blog/nosql-transaction/"/>
    <updated>2014-10-08T18:07:12+08:00</updated>
    <id>http://gavinhuang.github.io/blog/nosql-transaction</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>关系型数据库如SQL server, Oracle, mysql这类强一致性的数据库天然地支持数据库事务，而大部分NoSQL数据库（如Riak）则由于没有隔离性、锁机制等原因不能实现数据库事务，要实现事务控制则必须从应用层面来处理。本文以Riak为例，介绍基于nosql数据库的应用如何实现数据库事务的方案。</p>

<h3>事务和隔离性</h3>

<p>在开始介绍方案前，先简单回顾下事务的四个特性（ACID）：
-   atomicity
-   consistency
-   isolation
-   durability</p>

<p>其中，隔离性是指多个事务（用户）之前的操作不会相互影响，多个事务并行执行结果应该与各个事务串行执行结果一致。注意，这里说的是执行结果应该与串行执行一致，而不是必须串行地执行，因为串行执行会成为性能提升的瓶颈。不同的隔离性会产生不同的副作用，比如：</p>

<!--   more -->


<ul>
<li>Load Updates</li>
<li>Dirty Read</li>
<li>Non-repeatable read</li>
<li>Phantom read</li>
</ul>


<p>其中，第一项&#8221;更新丢失&#8221;在大部分强一致性数据库系统中不会出现，因为这些系统通常都会采用锁的机制来保证同一数据同时只能被一个事务修改。</p>

<p>围绕着如何在隔离性（以及他说产生的问题）与系统性能之间的平衡产生了一系列的隔离级别：
-   Read uncommitted
-   Read committed
-   Repeatable read
-   Serializable</p>

<blockquote><p>注意，数据库隔离级别的名称跟部分事务副作用有类似，甚至有人直接用隔离级别产生的副作用代替级别名称，留意这些，防止被这些概念搞混。</p></blockquote>

<h3>方案初探</h3>

<p>不少介绍数据库事务的资料都是以银行账户之间转账来说明数据库事务，这里也沿用这个传统：用户A需要先用户B转入一笔金额，在事务内需要进行如下操作：
1.   账户A扣款
2.   账户B打款</p>

<p>由于Riak不支持回滚操作，即不论第二步操作是否成功，第一步操作的结果都将保存在数据库中，所以需要增加一个“表”：事务日志，于是正常的操作转账将变为三步：
1.   账户A扣款
2.   账户B打款
3.   假如上述两步都成功则写入事务日志</p>

<p>具体来说：
这是事务开始之前的状态：
/account/a</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "name": “Gary",
</span><span class='line'>    "balance": [
</span><span class='line'>        {
</span><span class='line'>            " initial ": 100
</span><span class='line'>        }
</span><span class='line'>    ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>/account/b</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "name": “Gavin",
</span><span class='line'>    "balance": [
</span><span class='line'>        {
</span><span class='line'>            " initial ": 0
</span><span class='line'>        }
</span><span class='line'>    ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这是事务完成之后：
/account/a</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "name": “Gary",
</span><span class='line'>    "balance": [
</span><span class='line'>        {
</span><span class='line'>            "initial ": 100
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            "txid_20141008_xxx": -10
</span><span class='line'>        }
</span><span class='line'>    ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>/account/b</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "name": “Gavin",
</span><span class='line'>    "balance": [
</span><span class='line'>        {
</span><span class='line'>            " initial ": 0
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            "txid_20141008_xxx": 10
</span><span class='line'>        }
</span><span class='line'>    ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>/transactionlog/txid_20141008_xxx</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "from": “Gary",
</span><span class='line'>    "to": “Gavin"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>完成了这些之后，在读取时还需遵循这一的规则：
1.   读取账户余额时需要从balance中的历史记录中倒推计算得出
2.   balance记录只有在transactionlog表中存在对应的记录方为有效
3.   在事务范围内，忽略本事务id之后的事务id（即使是那些成功的事务）</p>

<p>只有在遵循了上述几个原则之后，才能保证在事务执行时的三步任意一步失败时，标志着整个事务失败了。其中，
-   1避免了强一致性数据库中锁的应用，又能避免lost updates的问题：所有的操作都有据可查，数据不会在执行更新操作时被覆盖。
-   2保证了原子性：一个失败全部失败
-   3保证了只有在事务开始之前的事务结果才是有效的，也即达到了read committed的隔离级别
-   三个原则一起保证了durability和consistency</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新认识volatile]]></title>
    <link href="http://gavinhuang.github.io/blog/recognize-volatile/"/>
    <updated>2014-09-26T18:15:40+08:00</updated>
    <id>http://gavinhuang.github.io/blog/recognize-volatile</id>
    <content type="html"><![CDATA[<h3>误解</h3>

<p>一直以来，我是这么理解volatile关键字的：该修饰符修饰的变量将不会被缓存（寄存器、处理器二级缓存等），而是直接写入主内存中或从直接主内存中读取。如此，不同的线程间对该变量的读/写到的值都是最新的，也可确保在多线程条件下的正确性，至于什么才叫正确、为什么必须要正确，之前并没有多想。</p>

<p>最近拜读了infoq的mini书：《深入理解Java内存模型》（<a href="http://www.infoq.com/cn/minibooks/java_memory_model">http://www.infoq.com/cn/minibooks/java_memory_model</a> ），让我重新认识了Volatile关键字的真实意义和虚拟机的实现机制。本文以本人对volatile的目的、实现等为线索，对该书中volatile部分叙述重新整理，并结合相关资料，试图对volatile做一个个人总结，希望对读者也有所裨益。</p>

<h3>Volatile的真正作用</h3>

<p>开门见山地说，Volatile修饰的变量可以作为线程间协作的“信号量”，此信号量从一个线程被“传递”到另外一个线程，以达到线程协作的目的。从这个角度上说，volatile与“锁”或Synchronized关键字类似，都能达到线程协作的目的。</p>

<!-- more -->


<p>但是，从volatile的基本含义(Java官方文档: <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.4</a>) 并不能得出上述结论：</p>

<blockquote><p>The Java programming language allows threads to access shared variables (§17.1). As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.
The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes.
A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable (§17.4).</p></blockquote>

<p>由上述定义可见，volatile是一个仅仅针对被修饰变量（的值）在不同线程中的一致性、可靠性而采取的效果类似“锁”的一种机制，但并未提及为什么通过对变量可见性的控制，就能达到线程协作的目。为解答这个问题，需要引入一个概念：</p>

<h3>指令重排</h3>

<p>这篇文章: <a href="http://kenwublog.com/illustrate-memory-reordering-in-cpu">http://kenwublog.com/illustrate-memory-reordering-in-cpu</a> 介绍了指令重排的背景。简单来说，编译器、CPU出于性能优化的目的会对程序员的指令（java源代码）的顺序进行适当调整，调整的规则不同的处理器类型有不同的策略，但都一个一条底线：有数据依赖的指令不会被重排。所谓数据依赖性是指：
两个操作访问同一个变量，并且两个操作之中至少有一个是写操作，则这两个操作具有数据依赖。
注：常见的x86处理器，不仅在有数据依赖的指令间不能重排，而且禁止了绝大部分指令重排，只允许使用StoreLoad类型的重排，即“写读”操作的重排。</p>

<p>所以Java虚拟机面临的问题是，如何既保证程序按照程序员的意图和顺序被执行(as-if-serial)，又能利用编译器、处理器的重排机制实现代码的优化。Java通过在指令之间插入内存屏障指令（以下省略“指令”，直接称为内存屏障）来达到这一目的。内存屏障是能够被处理器识别的，确保屏障指令前/后的用户指令不被重排的特殊指令。读和写的两种操作排列组合形成如下可能：</p>

<ul>
<li>LoadLoad：  确保该指令之前的 “读取” 指令，在该指令之后的 “读取” 指令之前执行，从内存角度来说：“之前的指令” 首先从主内存装载变量之后，”之后的指令“ 才能装载</li>
<li>LoadStore： 确保该指令之前的 “读取” 指令，在该指令之后的 “写入” 指令之前执行，从内存角度来说：“之前的指令” 首先从主内存装载变量之后，”之后的指令“ 才能被写入主内存。</li>
<li>StoreStore：确保该指令之前的 “写入“ 指令，在该指令之后的 “写入” 指令之前执行，从内存角度来说：“之前的指令” 首先写入主内存（对其他线程可见）之后，“之后的指令”才能写入到主内存中。</li>
<li>StoreLoad： 确保该指令之前的 “写入” 指令， 在该指令之后的 “读取” 指令之前执行，从内存角度来说： “之前的指令” 写入主内存，对其他线程可见（也可理解为尽到了通知的义务）之后，“之后的指令” 才能执行。</li>
</ul>


<h4>Volatile的重排规则</h4>

<p>至此，我们可以回头看看Volatile的基本特性:</p>

<ul>
<li>当写一个Volatile变量时，要求该线程把变量对应的值刷新到主内存中。</li>
<li>当读一个Volatile变量时，线程要将该变量在本地内存中的值置为无效，而从主内存中读取。</li>
</ul>


<p>为实现上述特性，Java内存模型（具体来说是JSR133）给Volatile定义了如下重排规则：</p>

<ol>
<li>当第一个操作是Volatile读时，不能与其后的任何操作进行重排</li>
<li>当第二个操作是Volatile写时，不能与之前的任何操作进行重排（此处有些疑问，应该只需不与写操作重排即可）</li>
<li>当 第一个操作是Volatile写，第二个操作是Volatile读时，不能进行重排。</li>
</ol>


<p>通过以上的规则，结合如下代码：
Thread-write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">readyFlag</span><span class="o">;</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="kt">int</span> <span class="n">value</span><span class="o">=</span><span class="mi">100</span><span class="o">;</span><span class="c1">//该变量可以被看成是消息体</span>
</span><span class='line'><span class="n">readyFlag</span><span class="o">=</span><span class="kc">true</span><span class="c1">//表示消息已经就绪或发送完毕</span>
</span></code></pre></td></tr></table></div></figure>


<p>Thread-read:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">...</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">readyFlag</span><span class="o">){</span><span class="c1">//消息已就绪</span>
</span><span class='line'>  <span class="n">myValue</span><span class="o">=</span><span class="n">value</span><span class="c1">//读取最新的值，即接收消息</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不难得出，volatile除了保证自身的值是volatile的之外，还可控制其他变量的行为，实现线程协作。</p>

<h3>延伸：重排规则的实现</h3>

<p>由于Java内存模型通过插入内存屏障到达控制处理器的重排规则的目的，为了达成如上的规则，需要在二进制指令中的合适位置插入合适的屏障指令，下表列出了Volatile 的3个重排规则需要实现的屏障：</p>

<ol>
<li>第一个操作是Volatile读时：在该指令之后插入：

<ol type="a">
<li>LoadLoad指令（控制之后的读操作不重排）；</li>
<li>插入LoadStore指令（控制之后的写操作不重排）</li>
</ol>
</li>
<li>第二个操作是Volatile写时：在该指令之前插入一个StoreStore指令（控制之前的写操作不重排）</li>
<li>第一个操作是Volatile写   ：在该指令之后插入StoreLoad指令，以控制之后的Volatile读操作不被重排</li>
</ol>


<p>补充条件： 由于很难判断Volatile读/写操作是否为线程执行的最后/第一个指令，所以：</p>

<ul>
<li>在Volatile写之后插入StoreLoad指令</li>
<li>在Volatile读之前插入StoreLoad指令</li>
</ul>


<p>如此一来，涉及Volatile的指令前后将布满了内存模型要求的内存屏障变量，这样的结果虽然可以确保程序的正确性(as-if-serial)，但却影响了性能，所以Java内存模型规定还可以在此基础上进行优化，比如将两个内存屏障（其中一个为上一个指令之后的屏障，另一个为下一个指令之前的屏障）进行合并、省略。</p>

<blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>
]]></content>
  </entry>
  
</feed>
